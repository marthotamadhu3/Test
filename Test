import java.nio.file.Path;
import java.nio.file.Paths;
import org.apache.commons.io.FilenameUtils;

public class SafeFileUtil {

    // 1) Compute your base directory as a canonical, trailing-slash String
    private static final String BASE_CANONICAL;
    static {
        try {
            BASE_CANONICAL = 
                new java.io.File("/safe/base/directory")
                  .getCanonicalPath()
                + java.io.File.separator;
        } catch (Exception e) {
            throw new ExceptionInInitializerError(e);
        }
    }

    /**
     * Returns a safe Path for a user-supplied filename.
     * Uses Commons-IO to normalize and verify containment in one pass.
     */
    public static Path getSafePath(String filename) {
        // 2) Whitelist: only allow simple names
        if (filename == null || !filename.matches("[A-Za-z0-9._-]+")) {
            throw new SecurityException("Invalid filename");
        }

        // 3) Build combined path string
        String combined = BASE_CANONICAL + filename;

        // 4) Normalize with Commons-IO (removes ../, //, etc.)
        //     NOTE: the 'true' flag enforces POSIX-style separators.
        String normalized = FilenameUtils.normalize(combined, true);
        if (normalized == null || 
            !FilenameUtils.directoryContains(BASE_CANONICAL, normalized)) {
            throw new SecurityException("Path traversal attempt blocked");
        }

        // 5) Only now convert to Pathâ€”this is the one and only Path.resolve/Paths.get you ever do:
        return Paths.get(normalized);
    }
}
